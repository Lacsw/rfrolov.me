---
title: "Eine eigene Statuszeile für Claude Code erstellen"
description: "Wie man eine informative Statuszeile mit Model-Info, Kontext-Nutzung und Git-Status in Claude Code CLI erstellt."
date: "2026-01-19"
tags: ["claude-code", "bash", "cli", "developer-tools"]
featured: true
---

Claude Code unterstützt eigene Statuszeilen via Bash-Skripte. Hier zeige ich, wie man eine baut, die Model, Kontext-Nutzung und Git-Status auf einen Blick anzeigt.

## Schnellstart

Der schnellste Weg — einfach in Claude Code ausführen:

```bash
/statusline show model name and context percentage with a progress bar
```

Claude Code generiert das Skript und aktualisiert die Einstellungen automatisch. Für volle Kontrolle, weiterlesen.

## Ergebnis

<div className="my-6 rounded-lg bg-[#1a1a1a] p-4 font-mono text-sm">
  <span style={{color: '#00BFFF'}}>Opus 4.5</span>
  <span style={{color: '#9ca3af'}}> [====      ] </span>
  <span style={{color: '#FACC15'}}>43%</span>
  <span style={{color: '#9ca3af'}}> | 86k/200k | </span>
  <span style={{color: '#00BFFF'}}>rfrolov.me</span>
  <span style={{color: '#60a5fa'}}>(</span>
  <span style={{color: '#f87171'}}>main</span>
  <span style={{color: '#60a5fa'}}>)</span>
  <span style={{color: '#FACC15'}}> ✗</span>
</div>

## Manuelle Einrichtung

**1.** In `~/.claude/settings.json` hinzufügen:

```json
{
  "statusLine": {
    "type": "command",
    "command": "bash ~/.claude/statusline.sh"
  }
}
```

**2.** `~/.claude/statusline.sh` erstellen und ausführbar machen (`chmod +x`):

<CollapsibleCode title="~/.claude/statusline.sh">
```bash showLineNumbers
#!/bin/bash

input=$(cat)

# Daten extrahieren
model_name=$(echo "$input" | jq -r '.model.display_name // .model.id')
cwd=$(echo "$input" | jq -r '.workspace.current_dir')
project_dir=$(echo "$input" | jq -r '.workspace.project_dir')
total_input=$(echo "$input" | jq -r '.context_window.total_input_tokens // 0')
context_size=$(echo "$input" | jq -r '.context_window.context_window_size // 0')
used_pct=$(echo "$input" | jq -r '.context_window.used_percentage // 0' | cut -d. -f1)

# Modellname kürzen
short_model="$model_name"
[[ "$model_name" =~ Opus ]] && short_model="Opus 4.5"
[[ "$model_name" =~ Sonnet ]] && short_model="Sonnet 4"
[[ "$model_name" =~ Haiku ]] && short_model="Haiku 3.5"

# Tokens formatieren (42000 -> 42k)
format_tokens() {
    local n=$1
    [ "$n" -ge 1000 ] && echo "$((n / 1000))k" || echo "$n"
}
tokens_display=$(format_tokens "$total_input")
context_display=$(format_tokens "$context_size")

# Fortschrittsbalken
bar_width=10
filled=$((used_pct * bar_width / 100))
empty=$((bar_width - filled))
progress_bar="["
for ((i=0; i<filled; i++)); do progress_bar+="="; done
for ((i=0; i<empty; i++)); do progress_bar+=" "; done
progress_bar+="]"

# Git-Info
project_name=$(basename "$project_dir")
git_branch=""
if git -C "$cwd" rev-parse --git-dir > /dev/null 2>&1; then
    git_branch=$(git -C "$cwd" symbolic-ref --short HEAD 2>/dev/null || \
                 git -C "$cwd" rev-parse --short HEAD 2>/dev/null)
fi

# Farben
CYAN=$'\033[36m' YELLOW=$'\033[33m' RED=$'\033[31m' BLUE=$'\033[34m' RESET=$'\033[0m'

# Ausgabe
if [ -n "$git_branch" ]; then
    dirty=""
    git -C "$cwd" diff-index --quiet HEAD -- 2>/dev/null || dirty=" ${YELLOW}✗${RESET}"
    git_status="${CYAN}${project_name}${RESET}${BLUE}(${RED}${git_branch}${BLUE})${RESET}${dirty}"
else
    git_status="${CYAN}${project_name}${RESET}"
fi

echo "${CYAN}${short_model}${RESET} ${progress_bar} ${YELLOW}${used_pct}%${RESET} | ${tokens_display}/${context_display} | ${git_status}"
```
</CollapsibleCode>

## Verfügbare Daten

Claude Code übergibt JSON via stdin an dein Skript. Wichtige Felder:

| Feld | Beschreibung |
|------|-------------|
| `model.id`, `model.display_name` | Aktuelles Model-ID und Name |
| `context_window.used_percentage` | Vorberechneter % des genutzten Kontexts |
| `context_window.total_input_tokens` | Kumulative Input-Token-Anzahl |
| `context_window.total_output_tokens` | Kumulative Output-Token-Anzahl |
| `context_window.context_window_size` | Maximale Kontextfenstergröße |
| `cost.total_cost_usd` | Gesamte Sitzungskosten in USD |
| `cost.total_duration_ms` | Gesamtzeit seit Sitzungsstart |
| `cost.total_lines_added` / `removed` | Geänderte Codezeilen |
| `workspace.current_dir` | Aktuelles Arbeitsverzeichnis |
| `workspace.project_dir` | Verzeichnis, in dem Claude Code gestartet wurde |
| `vim.mode` | Aktueller Vim-Modus (`NORMAL` / `INSERT`) |
| `session_id` | Eindeutige Sitzungs-ID |

<Callout variant="note">
  Das Skript läuft nach jeder Assistenten-Nachricht, gedrosselt auf 300ms. Schnell halten — keine Netzwerk-Aufrufe.
</Callout>

<Callout variant="warning">
  **Rate-Limits nicht verfügbar.** Stündliche Nutzungslimits werden nicht an Statuszeilen-Skripte übergeben. [Feature-Request](https://github.com/anthropics/claude-code/issues/18121).
</Callout>

## Anpassungen

**Alternative Fortschrittsbalken:**

```bash
# Blöcke: [▓▓▓░░░░░░░]
for ((i=0; i<filled; i++)); do progress_bar+="▓"; done
for ((i=0; i<empty; i++)); do progress_bar+="░"; done

# Punkte: [●●●○○○○○○○]
for ((i=0; i<filled; i++)); do progress_bar+="●"; done
for ((i=0; i<empty; i++)); do progress_bar+="○"; done
```

**Farbcodierter Prozentsatz:**

```bash
[ "$used_pct" -lt 50 ] && pct_color=$'\033[32m' || \
[ "$used_pct" -lt 80 ] && pct_color=$'\033[33m' || pct_color=$'\033[31m'
```

**Sitzungskosten anzeigen:**

```bash
cost=$(echo "$input" | jq -r '.cost.total_cost_usd // 0')
# Zur Ausgabe hinzufügen: | \$${cost}
```

<Callout variant="tip">
  Zum Entfernen: `/statusline delete` ausführen oder das `statusLine`-Feld aus `settings.json` entfernen.
</Callout>
